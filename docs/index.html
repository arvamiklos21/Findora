// findora-feed: cursoros, streaming XML olvasás – CPU-barát
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname;

    // ---- CORS ----
    const CORS = {
      "access-control-allow-origin": "*",
      "access-control-allow-methods": "GET, OPTIONS",
      "access-control-allow-headers": "Content-Type",
    };
    if (request.method === "OPTIONS") return new Response(null, { headers: CORS });

    // Rövid helper
    const json = (obj, status=200, extra={}) =>
      new Response(JSON.stringify(obj), {
        status,
        headers: { "content-type": "application/json; charset=utf-8", ...CORS, ...extra },
      });

    // ======= Route-k =======
    if (path === "/api/tchibo") {
      return pagedXmlProxy({
        request, env, ctx,
        FEED_URL: env.FEED_TCHIBO_URL,     // pl. a ProductSup XML URL-je
        PARTNER_NAME: "Tchibo.hu",
      });
    }
    if (path === "/api/regiojatek") {
      return pagedXmlProxy({
        request, env, ctx,
        FEED_URL: env.FEED_REGIO_URL,
        PARTNER_NAME: "RegioJáték",
      });
    }
    if (path === "/api/jateksziget") {
      return pagedXmlProxy({
        request, env, ctx,
        FEED_URL: env.FEED_JATEKSZIGET_URL,
        PARTNER_NAME: "Játéksziget",
      });
    }

    // Egyszerű ping
    if (path === "/api/ping") return json({ ok: true });

    return new Response("Not found", { status: 404, headers: CORS });
  },
};

/**
 * Cursoros, streaming XML feldolgozó.
 * Nem épít DOM-ot, csak <item>…</item> blokkokat halász ki.
 * Query: ?page_size=20&cursor=<base64>
 */
async function pagedXmlProxy({ request, FEED_URL, PARTNER_NAME }) {
  const url = new URL(request.url);
  const pageSize = clampInt(url.searchParams.get("page_size"), 1, 50) || 20;

  // Cursor: az XML-en belüli "hányadik itemtől" folytassuk
  const cursorStr = url.searchParams.get("cursor") || "";
  let startIndex = 0;
  try {
    if (cursorStr) startIndex = JSON.parse(atob(cursorStr)).i|0;
  } catch (_) { /* ignore */ }

  // CDN cache kulcs: feed + startIndex + pageSize
  const cacheKey = new Request(`${FEED_URL}#${startIndex}:${pageSize}`);
  const cache = caches.default;
  const cached = await cache.match(cacheKey);
  if (cached) {
    return new Response(cached.body, {
      status: 200,
      headers: new Headers(cached.headers),
    });
  }

  // XML lekérése (stream)
  const resp = await fetch(FEED_URL, { cf: { cacheTtl: 300, cacheEverything: false } });
  if (!resp.ok || !resp.body) {
    return new Response(JSON.stringify({ items: [], nextCursor: null }), {
      status: 200,
      headers: {
        "content-type": "application/json; charset=utf-8",
        "access-control-allow-origin": "*"
      },
    });
  }

  // Stream feldolgozás
  const reader = resp.body.getReader();
  const decoder = new TextDecoder("utf-8");
  let buf = "";
  let seen = 0;
  const out = [];

  // item tag neve: <item>, <SHOPITEM>, <product> stb.
  const OPEN_RE  = /<(item|SHOPITEM|product)\b[^>]*>/i;
  const CLOSE_RE = /<\/(item|SHOPITEM|product)>/i;

  while (true) {
    const { value, done } = await reader.read();
    buf += value ? decoder.decode(value, { stream: true }) : "";
    let progressed = true;

    while (progressed) {
      progressed = false;
      const open = OPEN_RE.exec(buf);
      if (!open) break;
      const close = CLOSE_RE.exec(buf);
      if (!close) break;
      if (close.index < open.index) {
        buf = buf.slice(close.index + close[0].length);
        progressed = true;
        continue;
      }
      const itemXml = buf.slice(open.index, close.index + close[0].length);
      buf = buf.slice(close.index + close[0].length);
      progressed = true;

      const idx = seen++;
      if (idx < startIndex) continue;

      // ----- Robust mező-kinyerés -----
      const title = pickFirst(itemXml, [
        "title","PRODUCTNAME","g:title","NAME","PRODUCT_NAME"
      ]) || "(Nincs cím)";

      const urlLink = pickFirst(itemXml, [
        "link","URL","DEEPLINK","g:link","PRODUCT_URL","URL_PRODUCT"
      ]);

      const image = firstHttpImageFrom(itemXml);

      const desc = bestDescriptionFrom(itemXml);

      // Ár (most erősebb felismerő – Tchibo g:price / Ft / HUF)
      const nowNum = scanAnyPrice(itemXml);
      const oldNum = scanAnyOldPrice(itemXml);

      let discount = 0;
      if (isFiniteNum(nowNum) && isFiniteNum(oldNum) && oldNum > 0 && nowNum < oldNum) {
        discount = Math.round((1 - nowNum/oldNum) * 100);
      }

      out.push({
        title,
        url: urlLink,
        image,
        desc,
        price: isFiniteNum(nowNum) ? formatHUF(nowNum) : "",  // mindig legyen string is
        priceNum: isFiniteNum(nowNum) ? nowNum : null,
        oldPriceNum: isFiniteNum(oldNum) ? oldNum : null,
        discount,
        partner: PARTNER_NAME,
      });

      if (out.length >= pageSize) {
        const nextCursor = btoa(JSON.stringify({ i: idx + 1 }));
        const res = new Response(JSON.stringify({ items: out, nextCursor }), {
          headers: {
            "content-type": "application/json; charset=utf-8",
            "access-control-allow-origin": "*",
            // 10 perc public cache cursoronként
            "cache-control": "public, max-age=600, s-maxage=600",
          },
        });
        await caches.default.put(cacheKey, res.clone());
        return res;
      }
    }

    if (done) {
      const res = new Response(JSON.stringify({ items: out, nextCursor: null }), {
        headers: {
          "content-type": "application/json; charset=utf-8",
          "access-control-allow-origin": "*",
          "cache-control": "public, max-age=300, s-maxage=300",
        },
      });
      await caches.default.put(cacheKey, res.clone());
      return res;
    }
  }
}

/* =======================
   ===== utilok =====
   ======================= */
function clampInt(v, min, max) {
  const n = parseInt(v, 10);
  if (!Number.isFinite(n)) return null;
  return Math.min(max, Math.max(min, n));
}
function cleanup(s) {
  return String(s || "")
    .replace(/<!\[CDATA\[(.*?)\]\]>/gs, "$1")
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .trim();
}
function isFiniteNum(n){ return typeof n === "number" && Number.isFinite(n); }

// HU ár konverzió: számjegyeket gyűjtjük – HUF/Ft esetben elég (decimális eldobható)
function toHUF(s) {
  if (!s) return null;
  const digits = String(s).replace(/[^\d]/g, "");
  if (!digits) return null;
  const n = Number(digits);
  return Number.isFinite(n) ? n : null;
}
function formatHUF(n) {
  return new Intl.NumberFormat("hu-HU").format(n) + " Ft";
}

/* =======================
   ===== XML helper =====
   ======================= */

// Tagnév listából az első találat tartalma (namespace-t is tűr: prefix:tag)
function pickFirst(block, tagNames) {
  for (const raw of tagNames) {
    const name = raw.replace(/^.*:/, ""); // "g:price" -> "price"
    const rx = new RegExp(`<\\s*(?:[A-Za-z0-9_]+:)?${name}\\b[^>]*>([\\s\\S]*?)<\\/\\s*(?:[A-Za-z0-9_]+:)?${name}\\s*>`, "i");
    const m = rx.exec(block);
    if (m) return cleanup(m[1]);
  }
  return "";
}

// Attribútum keresés: <tag attr="...">
function pickAttr(block, tagNames, attrNames) {
  for (const raw of tagNames) {
    const name = raw.replace(/^.*:/, "");
    const rx = new RegExp(`<\\s*(?:[A-Za-z0-9_]+:)?${name}\\b([^>]*)>`, "i");
    const m = rx.exec(block);
    if (m) {
      const attrs = m[1] || "";
      for (const a of attrNames) {
        const ra = new RegExp(`${a}\\s*=\\s*["']([^"']+)["']`, "i");
        const ma = ra.exec(attrs);
        if (ma) return cleanup(ma[1]);
      }
    }
  }
  return "";
}

/* =======================
   ===== KÉP / LEÍRÁS =====
   ======================= */
function firstHttpImageFrom(block){
  // közvetlen image tagek
  const cand = [
    "g:image_link","IMAGE_LINK","IMAGEURL","IMAGE_URL","IMGURL","IMG_URL",
    "IMGURL_ALTERNATIVE","IMAGE1","IMAGE_URL_1","URL_IMAGE","image","image_url","img","MAIN_IMAGE_URL"
  ];
  const v1 = pickFirst(block, cand);
  if (/^https?:\/\//i.test(v1)) return v1.trim();

  // <IMAGES><IMAGE>...</IMAGE></IMAGES>
  const m1 = block.match(/<\s*(?:[A-Za-z0-9_]+:)?IMAGES[\s\S]*?<\s*(?:[A-Za-z0-9_]+:)?IMAGE[^>]*>([\s\S]*?)<\/\s*(?:[A-Za-z0-9_]+:)?IMAGE\s*>/i);
  if (m1) {
    const inside = m1[1].replace(/<!\[CDATA\[|\]\]>/g,'').trim();
    const u = (inside.match(/https?:\/\/[^\s<>"']+/i)||[])[0];
    if (u) return u;
  }

  // általános regex: az első http kép (jpg/png/webp/jpeg)
  const m2 = block.match(/https?:\/\/[^\s<>"']+\.(?:jpg|jpeg|png|webp)/i);
  if (m2) return m2[0];

  return "";
}

function bestDescriptionFrom(block){
  const cand = [
    "g:description","DESCRIPTION","LONGDESC","LONGDESCRIPTION","DESCRIPTION_LONG",
    "PRODUCT_DESC","DESCRIPTION_SHORT","SHORTDESC","DESC","description","short_description"
  ];
  const v = pickFirst(block, cand);
  if (v) {
    const txt = v.replace(/<[^>]+>/g,' ').replace(/\s+/g,' ').trim();
    if (txt) return txt.slice(0, 220);
  }
  return "";
}

/* =======================
   ===== ÁR FELISMERŐ =====
   ======================= */
const PRICE_TAGS = [
  "g:price","g:sale_price","g:price_amount","g:price_value","g:sale_price_amount",
  "PRICE_VAT","PRICE_WITH_VAT","PRICE_FINAL","PRICE_TAX","PRICE",
  "PRICE_GROSS","PRICE_BRUTTO","PRICE_BRUT","PRICE_WITH_TAX",
  "CURPRICE","CURRENT_PRICE","SALE_PRICE","PRICE_HUF","PRICE_VAT_HUF",
  "AMOUNT","AMOUNT_VAT","AMOUNT_WITH_VAT","PRICEVALUE","PRICE_VALUE",
  "FINAL_PRICE","PRICE_FINAL_WITH_VAT","FINAL_PRICE_GROSS","PRICEWITHVAT",
  "PRICE_W_VAT","PRICE_VAT_VALUE","AKTUALIS_AR","CENA_S_DPH",
  "price","sale_price","final_price","current_price","amount","value"
];
const OLD_TAGS = [
  "g:price_old","g:regular_price","g:list_price",
  "OLDPRICE","OLD_PRICE","PRICE_BEFORE","PRICE_ORIG","ORIGINAL_PRICE",
  "PRICE_OLD","PRICE_BEFORE_DISCOUNT","WAS_PRICE","LIST_PRICE",
  "BASE_PRICE","RETAIL_PRICE","REGULAR_PRICE","ORIG_PRICE","PRICE_BEFORE_VAT",
  "old_price","list_price","original_price","regular_price"
];

function scanAnyPrice(block) {
  // 1) direkt tag tartalma
  let text = pickFirst(block, PRICE_TAGS);
  let n = toHUF(text);
  if (n != null) return n;

  // 2) attribútumok (amount/value/with_vat stb.)
  const attr = pickAttr(block, PRICE_TAGS, ["amount","value","price","gross","with_vat","val","amt"]);
  n = toHUF(attr);
  if (n != null) return n;

  // 3) <prefix:price>...</prefix:price>
  let m = block.match(/<\s*(?:[A-Za-z0-9_]+:)?(price|sale_price|final_price|current_price)\b[^>]*>([\s\S]*?)<\/\s*(?:[A-Za-z0-9_]+:)?\1\s*>/i);
  if (m) {
    n = toHUF(m[2]);
    if (n != null) return n;
  }

  // 4) PRICE* tetszőleges tagban
  const any = block.match(/<\s*(?:[A-Za-z0-9_]+:)?PRICE[^>\s]*\b[^>]*>([\s\S]*?)<\/\s*(?:[A-Za-z0-9_]+:)?PRICE[^>]*>/gi);
  if (any) {
    for (const seg of any) {
      const inner = seg.replace(/<[^>]+>/g," ").trim();
      n = toHUF(inner);
      if (n != null) return n;
    }
  }

  // 5) „9990 Ft” / „9 990 HUF”
  const near = block.match(/(\d[\d\s\.,]{1,12})\s*(?:Ft|HUF)/i);
  if (near) {
    n = toHUF(near[1]);
    if (n != null) return n;
  }

  // 6) Google feed common: "12345 HUF" teljes mező
  const gprice = pickFirst(block, ["g:price","g:sale_price"]);
  if (gprice) {
    const val = (gprice.match(/^\s*([\d\.,\s]+)/)||[])[1];
    n = toHUF(val);
    if (n != null) return n;
  }

  return null;
}

function scanAnyOldPrice(block){
  // egyszerűbb: a fentihez hasonló, de OLD_TAGS prioritással
  let text = pickFirst(block, OLD_TAGS);
  let n = toHUF(text);
  if (n != null) return n;

  // „WAS price” szerű minták
  const near = block.match(/(?:was|before|régi|eredeti)[^0-9]{0,12}(\d[\d\s\.,]{1,12})\s*(?:Ft|HUF)/i);
  if (near) {
    n = toHUF(near[1]);
    if (n != null) return n;
  }
  return null;
}
